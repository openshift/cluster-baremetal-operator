package provisioning

import (
	"context"
	"encoding/base64"
	"fmt"

	"github.com/pkg/errors"
	"golang.org/x/crypto/bcrypt"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	utilerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	"github.com/openshift/cluster-baremetal-operator/pkg/crypto"
	"github.com/openshift/cluster-baremetal-operator/pkg/resourceapply"
)

const (
	baremetalSecretName = "metal3-mariadb-password" // #nosec
	baremetalSecretKey  = "password"
	ironicUsernameKey   = "username"
	ironicPasswordKey   = "password"
	ironicHtpasswdKey   = "htpasswd"
	ironicConfigKey     = "auth-config"
	ironicSecretName    = "metal3-ironic-password"
	ironicrpcSecretName = "metal3-ironic-rpc-password" // #nosec
	ironicrpcUsername   = "rpc-user"
	ironicUsername      = "ironic-user"
	inspectorSecretName = "metal3-ironic-inspector-password"
	inspectorUsername   = "inspector-user"
	tlsSecretName       = "metal3-ironic-tls" // #nosec
	pullSecretName      = "pull-secret"
)

// createMariadbPasswordSecret creates a Secret for Mariadb password
func createMariadbPasswordSecret(ctx context.Context, info *ProvisioningInfo) error {
	password, err := crypto.GenerateRandomPassword()
	if err != nil {
		return err
	}

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      baremetalSecretName,
			Namespace: info.Namespace,
		},
		StringData: map[string]string{
			baremetalSecretKey: password,
		},
	}

	if err := controllerutil.SetControllerReference(info.ProvConfig, secret, info.Scheme); err != nil {
		return err
	}

	_, _, err = resourceapply.ApplySecret(ctx, info.Client, info.EventRecorder, secret, nil)
	return err
}

func createIronicSecret(ctx context.Context, info *ProvisioningInfo, name string, username string, configSection string) error {
	password, err := crypto.GenerateRandomPassword()
	if err != nil {
		return err
	}
	hash, err := bcrypt.GenerateFromPassword([]byte(password), 5) // Use same cost as htpasswd default
	if err != nil {
		return err
	}
	// Change hash version from $2a$ to $2y$, as generated by htpasswd.
	// These are equivalent for our purposes.
	// Some background information about this : https://en.wikipedia.org/wiki/Bcrypt#Versioning_history
	// There was a bug 9 years ago in PHP's implementation of 2a, so they decided to call the fixed version 2y.
	// httpd decided to adopt this (if it sees 2a it uses elaborate heuristic workarounds to mitigate against the bug,
	// but 2y is assumed to not need them), but everyone else (including go) was just decided to not implement the bug in 2a.
	// The bug only affects passwords containing characters with the high bit set, i.e. not ASCII passwords generated here.

	// Anyway, Ironic implemented their own basic auth verification and originally hard-coded 2y because that's what
	// htpasswd produces (see https://review.opendev.org/738718). It is better to keep this as one day we may move the auth
	// to httpd and this would prevent triggering the workarounds.
	hash[2] = 'y'

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: info.Namespace,
		},
		StringData: map[string]string{
			ironicUsernameKey: username,
			ironicPasswordKey: password,
			ironicHtpasswdKey: fmt.Sprintf("%s:%s", username, hash),
			ironicConfigKey: fmt.Sprintf(`[%s]
auth_type = http_basic
username = %s
password = %s
`,
				configSection, username, password),
		},
	}

	if err := controllerutil.SetControllerReference(info.ProvConfig, secret, info.Scheme); err != nil {
		return err
	}

	_, _, err = resourceapply.ApplySecret(ctx, info.Client, info.EventRecorder, secret, nil)
	return err
}

// createRegistryPullSecret creates a copy of the pull-secret in the
// openshift-config namespace for use with LocalObjectReference
func createRegistryPullSecret(ctx context.Context, info *ProvisioningInfo) error {
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      pullSecretName,
			Namespace: info.Namespace,
		},
		StringData: map[string]string{
			corev1.DockerConfigJsonKey: base64.StdEncoding.EncodeToString(info.OpenshiftConfigSecret),
		},
		Type: corev1.SecretTypeDockerConfigJson,
	}

	if err := controllerutil.SetControllerReference(info.ProvConfig, secret, info.Scheme); err != nil {
		return err
	}

	_, _, err := resourceapply.ApplySecret(ctx, info.Client, info.EventRecorder, secret, nil)
	return err
}

func EnsureAllSecrets(ctx context.Context, info *ProvisioningInfo) (bool, error) {
	// Create a Secret for the Mariadb Password
	if err := createMariadbPasswordSecret(ctx, info); err != nil {
		return false, errors.Wrap(err, "failed to create Mariadb password")
	}
	// Create a Secret for the Ironic Password
	if err := createIronicSecret(ctx, info, ironicSecretName, ironicUsername, "ironic"); err != nil {
		return false, errors.Wrap(err, "failed to create Ironic password")
	}
	// Create a Secret for the Ironic RPC Password
	if err := createIronicSecret(ctx, info, ironicrpcSecretName, ironicrpcUsername, "json_rpc"); err != nil {
		return false, errors.Wrap(err, "failed to create Ironic rpc password")
	}
	// Create a Secret for the Ironic Inspector Password
	if err := createIronicSecret(ctx, info, inspectorSecretName, inspectorUsername, "inspector"); err != nil {
		return false, errors.Wrap(err, "failed to create Inspector password")
	}
	// Generate/update TLS certificate
	if err := createOrUpdateTlsSecret(ctx, info); err != nil {
		return false, errors.Wrap(err, "failed to create TLS certificate")
	}
	// Create a Secret for the Registry Pull Secret
	if err := createRegistryPullSecret(ctx, info); err != nil {
		return false, errors.Wrap(err, "failed to create Registry pull secret")
	}
	return false, nil // ApplySecret does not use Generation, so just return false for updated
}

func DeleteAllSecrets(ctx context.Context, info *ProvisioningInfo) error {
	var secretErrors []error
	for _, sn := range []string{baremetalSecretName, ironicSecretName, inspectorSecretName, ironicrpcSecretName, tlsSecretName, pullSecretName} {
		secret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: sn, Namespace: info.Namespace}}
		if err := client.IgnoreNotFound(info.Client.Delete(ctx, secret, &client.DeleteOptions{})); err != nil {
			secretErrors = append(secretErrors, err)
		}
	}
	return utilerrors.NewAggregate(secretErrors)
}

// createOrUpdateTlsSecret creates a Secret for the Ironic and Inspector TLS.
// It updates the secret if the existing certificate is close to expiration.
func createOrUpdateTlsSecret(ctx context.Context, info *ProvisioningInfo) error {
	cert, err := crypto.GenerateTlsCertificate(info.ProvConfig.Spec.ProvisioningIP)
	if err != nil {
		return err
	}

	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      tlsSecretName,
			Namespace: info.Namespace,
		},
		Data: map[string][]byte{
			corev1.TLSCertKey:       cert.Certificate,
			corev1.TLSPrivateKeyKey: cert.PrivateKey,
		},
	}

	if err := controllerutil.SetControllerReference(info.ProvConfig, secret, info.Scheme); err != nil {
		return err
	}

	_, _, err = resourceapply.ApplySecret(ctx, info.Client, info.EventRecorder, secret, func(existing *corev1.Secret) (bool, error) {
		expired, err := crypto.IsTlsCertificateExpired(existing.Data[corev1.TLSCertKey])
		if err != nil {
			return false, err
		}
		return expired, nil
	})
	return err
}
